\textbf{I'm writing this section}\\


As Catalyst network scales up, the ledger partitions (partitions storing non-confidential accounts, confidential accounts, smart contract-based accounts) are expected to grow as new and existing users create new digital accounts stored on the ledger and generate more activity on the network, issuing an increasing number of token transfers, notably by using the services available on the network. Even though the current ledger state as well as the ledger state update of a partition may grow less rapidly than traditional blockchains which maintain every single transaction ever created, scaling techniques are considered to ensure the network performance not only remains stable but also improves as the network popularity grows. Indeed, as mentioned in section \ref{subsec:mot}, the approach followed to design Catalyst protocol took in consideration the reality that the global resource available across a network would genuinely increase as the network grows and should be seen as an advantage rather than a constraint. Said differently, Catalyst protocol was developed with the idea that a distributed ledger should naturally remain decentralised and secure as the ledger database and network scale up. Moreover, Catalyst ledger was inherently conceived to support various partitions and allow these partitions to communicate or exchange tokens in ways that wouldn't compromise the rules inherent to each of them. \\

This chapter continues in the lines of the chapter~\ref{Cha:CM} dedicated to Catalyst consensus-based protocol and comprises two parts: the first part dedicated to the use of sharding techniques applied to each partition for an efficient yet secure management of the partition state, and the second part devoted to partitions interoperability. % including those with locking scripts that cannot be unlocked due to the loss of private keys or programming errors. \\

\section{Dynamic Account Ordering}
Having the ability to prune a ledger (or blockchain) of obsolete data without compromising the integrity of the system offers a direct yet limited way to regulate the size of the ledger database.  , the state of a ledger partition comprises accounts that have different levels of activity, \textit{i.e.} are involved in a varying number of token transfer, and therefore require different level of resource to be maintained. Being able to distinguish between accounts that are active from those resulting in fewer transfer of tokens offer the possibility to better allocate resource available across the network. \\

As explained in section~\ref{Sec:AoC}, each partition on Catalyst ledger lists digital accounts address and their balance in KAT tokens, whether the balance is represented by a number in non-confidential account or a Pedersen Commitment in confidential account. In this section, we considered adding an extra field to each account that represents the account activity, called the account inertia (mentioned in section~\ref{Sec:AoC}).The inertia of an account is defined by the account activity relative to the overall activity of a partition and is updated at the end of each ledger cycle. The inertia of accounts involved in one or more token transfers during a ledger cycle decreases while the inertia of accounts inactive during the same period of time increases. The ordering of accounts in a ledger partition is then based on a Least Recently Used (LRU) algorithm that is ran at the end of each ledger cycle. Active accounts which have a low inertia sits at the top of the ledger partition state. Accounts with no activity gain inertia and are progressively moved towards the bottom of the ledger state. Accounts that have reached a critical inertia are eventually moved to DFS where they can still have accessed and re-activated for a period of time, after which they are removed permanently unless an explicit agreement is made between the account owner and the nodes responsible for maintaining DFS. \\

The ordering of accounts in a ledger partition based on the accounts inertia results in a dynamic multi-levelled structure regulated by the network activity. The accounts are split in sub-states, or shards, where each shard is characterised by a range of account inertia values. Assume a ensemble $\mathcal{M}$ of accounts stored on a ledger partition with each account $\mathcal{A}_i~\forall i \in \mathcal{M}$ defined by the set ($A_i, v_i, \epsilon_i$), respectively the account address, amount and inertia. A partition $\mathcal{P}$ is split in $s$ shards $(\mathcal{P}_1,..,\mathcal{P}_s)$ where each shard $\mathcal{P}_w~\forall w \in [1,s]$ comprises a subset $\mathcal{M}_w$ of accounts such that an account $\mathcal{A}_i$ in $\mathcal{M}_w$ is characterised by an inertia $\epsilon_i \in [\epsilon_w, \epsilon_{w+1})$ ($\epsilon_w$ is the inertia threshold separating shards $\mathcal{P}_{w-1}$ and $\mathcal{P}_{w}$).\\ 

Each shard in a partition thus comprises accounts that have similar level of activity on the network. Shards with active accounts will require more resource to be maintained and as such can be managed by heavy nodes. At the contrary, shards of accounts involved in fewer token transfers will result in more compact ledger partition state update and can thus rely on smaller nodes to generate these updates. The shards can thus be managed by separate worker pools with each worker pool characterised by a specific range of computing resources, such as the CPU~\cite{coremark} per node. \\

The global ledger state update generated during a ledger cycle thus comprise a set of ledger shard state update. Producers selected in the worker pool of a shard to generate the ledger shard state update can reach consensus following the consensus-based protocol described in the chapter~\ref{Cha:CM}. However, given that a transaction may embed a transfer of tokens between accounts stored on different shards, there needs to be a mechanism to ensure that any transfer, say from account $A$ to $B$, partially included the state update of the shard storing $A$ is also included in the state update of the shard storing $B$. Although each producer pool may reach consensus on the correct shard state update, a safeguard needs to be put in place to ensure that the global ledger state update does not destroy existing tokens nor create tokens outside the scope of the token injection mechanism. To that end, this section describes a new phase followed by the producers during a ledger cycle that take place during the synchronisation phase and ensure that any transaction is properly included in the state update of the different shards storing the accounts involved in said transaction.  Additional steps taken during the earlier ledger cycle phases are also described.

\section{Protocol in a Shard-based Ledger}

During the construction phase described in chapter~\ref{Cha:CM}, a producer $P_j$ computes a quantity $L_E^f$ that lists the transaction entries included in the transactions collected by producer during the period of time [$t_{n-1,0} - \Delta t_{freeze}, t_{n,0}$]. In a shard-based ledger, the producer $P_j$ is now a member of the producer pool tasked with updating the state of a ledger shard $\mathcal{P}_w$, defined by a subset $\mathcal{M}_w$ of accounts.\\

As such, $P_j$ does not store all $m_{n-1}$ transactions issued during the ledger cycle $\mathcal{C}_{n-1}$ in its mempool but instead only collects the subset $m_{n-1,w}$ of transactions that contain at least one entry involving  an account included in the subset $\mathcal{M}_w$.\\

Some of these $m_{n-1,w}$ transactions will include entries that involve accounts stored on other shards (of the same ledger partition). Let $\mathcal{E}^{in}_w$ be the set of transaction entries involving an account included in $\mathcal{M}_w$ and $\mathcal{E}^{out}_w$ the set of transaction entries involving an account not included in $\mathcal{M}_w$ such that $\mathcal{E}^{in}_w \cup \mathcal{E}^{out}_w$ comprises the $n_i$ entries $\{E_\alpha\}_{\alpha=1,..,n_i}$ of each transaction $Tx_i~\forall i \in  [1, m_{n-1,w}]$.\\

In chapter~\ref{Cha:CM}, a simple pool of producers agreed on the global state update of a ledger partition$\Delta L_n$ built during the cycle $\mathcal{C}_{n}$. In the context of a shard-based ledger, the producers tasked with updating the state of a ledger shard $\mathcal{P}_w$ work collaboratively to generate the ledger shard state update $\Delta L^w_n$. The set of shard state updates constitutes the global ledger state update: $\Delta L_n = \Delta L^1_n + ... + \Delta L^k_n + ...+ \Delta L^s_n$.\\ 

The $P$ producers responsible for the ledger shard $\mathcal{P}_w$ follow a protocol similar to that described in \ref{Cha:CM}. The differences, explained below.....

The producer $P_j$ executes the following steps to create $L_E^f$:
\begin{itemize}
\item For each transaction entry $E_\alpha$ in $\mathcal{E}^{in}_w$, $P_j$ creates a corresponding hash variable: 
\begin{center}
$O_\alpha = \mathcal{H}[E_\alpha~||~s]$
\end{center}
Each pair ($E_\alpha,O_\alpha$) is added to a list $L^s_E$. Steps (1) and (2) are repeated until all transactions have been processed.
\item	$P_j$ then creates a new list $L^f_E$ using the $M_w=\sum_{i=1}^{\mathcal{E}^{in}_w}n_i$ transaction entries listed in $L^s_E$ such that the transaction entries in $L^f_E = \{E_\beta\}_{\beta=1,...,M_w}$ are sorted following a lexicographical order based on their associated hash variable: $O_1 < O_2 < ... < O_\beta < ... < O_{M_w}$. 
\item $P_j$ also creates a hash table $HT_j$ using the entries in $\mathcal{E}^{in}_w$.
\item The producer then computes a new local hash:
\begin{equation}
\label{eq:hj_shard}
\fbox{$h_j = h_{\Delta j}~||~r(HT_j)~||~Id_j$}
\end{equation}
$h_j$ differs from the one defined in equation~\ref{eq:hj} as it includes $r(HT_j)$, the root of $HT_j$ hash table.
\end{itemize}
$P_j$ then broadcasts $h_j$ to the other producers in the network and collects other $\{h_k\}_{k \in P/j}$ contributions generated by its producer peers $\{P_k\}_{k \in P/j}$ as described in section \ref{subsec:comp}.\\

During the campaigning phase, $P_j$ verifies that the same local hash $h^{maj}_{\Delta j}$ is embedded in a majority $C^{maj}$ of contributions, where:
\begin{itemize}
\item $h^{maj}_{\Delta j}~||~r(HT^{maj}) = max[unique(h_{\Delta k}~||~r(HT_k))~\forall~k\in\{C_j\}]$
\item $C^{maj} = count[(h_{\Delta k} = h^{maj}_{\Delta j} \& r(HT_k) = r(HT^{maj}))~\forall~k\in\{C_j\}]$. 
\end{itemize}

The remaining steps in this phase are as described in section \ref{subsec:camp}.\\

During the voting phase, a producer $P_j$ verifying $h_{\Delta j}=h^{maj}$ creates its ballot as:
\begin{equation}
\label{eq:vj_shard}
\fbox{$v_j = \mathcal{H}(LSU_j)~||~r(HT^{maj})~||~\#(\mathcal{L}_j(vote))~||~Id_j$}
\end{equation}
$P_j$ then broadcasts $v_j$ to the other producers in the network and collects other $\{v_k\}_{k \in P/j}$ votes generated by its producer peers $\{P_k\}_{k \in C_n/j}$ as described in section \ref{subsec:comp}.\\

During the synchronisation phase, a producer $P_j$ computes a quantity $\mathbf{H_{j}}$ (equation~\eqref{eq:Hj}) that embeds the ledger state update generated a majority of producers within the producer pool. In the context of a shard-based ledger, the  quantity $\mathbf{H_{j}}$ is defined as:

 \begin{equation} 
\fbox{$\mathbf{H_{j} = \mathcal{H}(\Delta L^w_n)~||~\mathcal{H}(\mathcal{L}^{w}_{n}(vote))~||~HT^{maj}~||~Id_j}$}
\label{eq:Hj_shard}
\end{equation}
It includes the hash of the identifier list $\mathcal{L}^{w}_{n}(vote)$ of producers who voted correctly on the ledger shard state update $\mathcal{P}_w$.
It also includes the hast tree $HT^{maj}$ corresponding to the set of transaction entries $\mathcal{E}^{in}_w$ included in $\Delta L^w_n$. 

\section{Partitions Interdependencies}

Ledger partitions (partitions storing non-confidential accounts, confidential accounts,...)