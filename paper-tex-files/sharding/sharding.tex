\textbf{I'm writting this section}\\


As Catalyst network scales up, the ledger partitions (partitions storing non-confidential accounts, confidential accounts, smart contract-based accounts) are expected to grow as new and existing users create new digital accounts stored on the ledger and generate more activity on the network, issuing an increasing number of token transfers, notably by using the services available on the network. Even though the current ledger state as well as the ledger state update of a partition may grow less rapidly than traditional blockchains which maintain every single transaction ever created, scaling techniques are considered to ensure the network performance not only remains stable but also improves as the network popularity grows. Indeed, as mentioned in section \ref{subsec:mot}, the approach followed to design Catalyst protocol took in consideration the reality that the global resource available across a network would genuinely increase as the network grows and should be seen as an advantage rather than a constraint. Said differently, Catalyst protocol was developed with the idea that a distributed ledger should naturally remain decentralised and secure as the ledger database and network scale up. Moreover, Catalyst ledger was inherently conceived to support various partitions and allow these partitions to communicate or exchange tokens in ways that wouldn't compromise the rules inherent to each of them. \\

This chapter continues in the lines of the chapter~\ref{Cha:CM} dedicated to Catalyst consensus-based protocol and comprises two parts: the first part dedicated to the use of sharding techniques applied to each partition for an efficient yet secure management of the partition state, and the second part devoted to partitions interoperability. % including those with locking scripts that cannot be unlocked due to the loss of private keys or programming errors. \\

\section{Dynamic account ordering}
Having the ability to prune a ledger (or blockchain) of obsolete data without compromising the integrity of the system offers a direct way to regulate the size of the ledger database. Furthermore, the state of a ledger partition comprises accounts that have different levels of activity, \textit{i.e.} are involved in a varying number of token transfer, and therefore require different level of resource to be maintained. Being able to distinguish between accounts that are active from those resulting in fewer transfer of tokens offer the possibility to better allocate resource available across the network. \\

As explained in section~\ref{Sec:AoC}, each partition on Catalyst ledger lists digital accounts address and their balance in KAT tokens, whether the balance is represented by a number in non-confidential account or a Pedersen Commitment in confidential account. In this section, we considered adding an extra field to each account that represents the account activity, called the account inertia.The inertia of an account is defined by the account activity relative to the overall activity of a partition and is updated at the end of each ledger cycle. The inertia of accounts involved in one or more token transfers during a ledger cycle decreases while the inertia of accounts inactive during the same period of time increases. The ordering of accounts in a ledger partition is then based on a Least Recently Used (LRU) algorithm that is ran at the end of each ledger cycle. Active accounts which have a low inertia sits at the top of the ledger partition state. Accounts with no activity gain inertia and are progressively moved towards the bottom of the ledger state. Accounts that have reached a critical inertia are eventually moved to DFS where they can still have accessed and re-activated for a period of time, after which they are removed permanently unless an explicit agreement is made between the account owner and the nodes responsible for maintaining DFS. \\

The ordering of accounts in a ledger partition based on the accounts inertia results in a dynamic multi-levelled structure regulated by the network activity. The accounts are split in sub-states, or shards, where each shard is characterised by a range of account inertia values. Assume a ensemble $\mathcal{M}$ of accounts stored on a ledger partition with each account $\mathcal{A}_i \forall i \in \mathcal{M}$ now defined by the set ($A_i, v_i, \epsilon_i$), respectively the account address, amount and inertia. A partition $\mathcal{P}$ is split in $s$ shards $(\mathcal{P}_1,..,\mathcal{P}_s)$ where each shard $\mathcal{P}_j~\forall j \in [1,s]$ comprises a subset $\mathcal{M}_j$ of accounts such that an account $\mathcal{A}_i$ in $\mathcal{M}_j$ is characterised by an inertia $\epsilon_i \in [\epsilon_j, \epsilon_{j+1})$ ($\epsilon_j$ is the inertia threshold separating shards $\mathcal{P}_{j-1}$ and $\mathcal{P}_{j}$).\\ 

Each shard in a partition thus comprises accounts that have similar level of activity on the network. Shards with active accounts will require more resource to be maintained and as such can be managed by heavy nodes. At the contrary, shards of accounts involved in fewer token transfers will result in more compact ledger partition state update and can thus rely on smaller nodes to generate these updates. The shards can thus be managed by separate worker pools with each worker pool characterised by a specific range of computing resources, such as the CPU~\cite{coremark} per node. \\

The global ledger state update generated during a ledger cycle thus comprise a set of ledger shard state update. Producers selected in the worker pool of a shard to generate the ledger shard state update can reach consensus following the consensus-based protocol described in the chapter~\ref{Cha:CM}. However, given that a transaction may embed a transfer of tokens between accounts stored on different shards, there needs to be a mechanism to ensure that any transfer, say from account $A$ to $B$, partially included the state update of the shard storing $A$ is also included in the state update of the shard storing $B$. Although each producer pool may reach consensus on the correct shard state update, a safeguard needs to be put in place to ensure that the global ledger state update does not destroy existing tokens nor create tokens outside the scope of the token injection mechanism. To that end, this section describes a new phase followed by the producers during a ledger cycle that take place during the synchronisation phase and ensure that any transaction is properly included in the state update of the different shards storing the accounts invovled in said transaction.  

\section{Partitions}

Ledger partitions (partitions storing non-confidential accounts, confidential accounts,...)