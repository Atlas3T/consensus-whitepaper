Section~\ref{Sec:Reg} describes how user nodes register to become worker nodes and can be selected from the pool of workers to become a producer for a ledger cycle. This section describes the work performed by producer nodes in order to maintain the ledger state. The work performed by producers in order to generate a ledger state update $\Delta L_n$ for the ledger cycle $C_n$ starts at $t=t_{n,0}$ and last for a period of time $\Delta t_{cycle}$. At the end of the ledger cycle, nodes in the network use $\Delta L_n$ to update their local copy of the ledger state. This section describes the different phases of a ledger cycle. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Computation Phase}
\label{subsec:comp}

During the first phase (\textit{a.k.a} computation phase) of the ledger cycle $C_n$, a producer $P_j~\forall j \in P$ creates a local ledger state update and exchanges it with its peers.\\

The first phase starts at $t = t_c = t_{n,0}$ and lasts for a period of time $\Delta t_{c}$, therefore ending at $t_c+\Delta t_{c}$.

\subsubsection{Local ledger state update generation}

At $t = t_c$, the producer $P_j$ flushes its mempool from the $m_{n-1}$ transactions $\{Tx_i\}_{i=1,..,m_{n-1}}$ collected during the period of time [$t_{n-1,0} - \Delta t_{freeze}, t_{n,0}$] and uses these transactions to create a local ledger state update $\Delta L_{n,j}$. 
The production of $\Delta L_{n,j}$ lasts for a period of time [$t_c, t_c+ \Delta t_{c0}$] ($\Delta t_{c0} < \Delta t_{c}$). The producer uses a salt $s$, defined using a pseudo-random number generator that takes for seed the Merkel tree of the previous valid ledger state update $\Delta L_{n-1}$. The producer also creates a new hash tree $d_n$, to store the aggregated signature embedded in each of the $m_{n-1}$ transactions. $P_j$ then follows a series of steps: 

\begin{enumerate}
\item For each transaction $Tx_i~\forall i\in [1,m_{n-1}]$, $P_j$ verifies that the transaction is valid (see section~\ref{Sec:Val}) and if so, extracts the $n^i$ transaction entries (described in \ref{Sec:TEnt}) $\{E_\alpha\}_{\alpha=1,...,n_i}$, included in $Tx_i$. The producer also extracts the transaction signature and adds it to the hash tree $d_n$. Note that the transactions signature in $d_n$ are sorted in alphabetic order, as to ensure that two same sets of transaction signature result in the same hash tree.

\item For each transaction entry $E_\alpha$, $P_j$ creates a corresponding hash variable: 

\begin{center}
$O_\alpha = \mathcal{H}[E_\alpha~||~s]$
\end{center}

Each pair ($E_\alpha,O_\alpha$) is added to a list $L^s_E$. Steps (1) and (2) are repeated until all transactions have been processed.

\item	$P_j$ then creates a new list $L^f_E$ using the $M=\sum_{i=1}^{m_{n-1}}n_i$ transaction entries listed in $L^s_E$ (assuming all transactions are valid) such that the transaction entries in $L^f_E = \{E_\beta\}_{\beta=1,...,M}$ are sorted following a lexicographical order based on their associated hash variable: $O_1 < O_2 < ... < O_\beta < ... < O_M$. \textcolor{bulg}{This approach blurs the links between the token flows embedded in the transactions for a better anonymity of the users involved in said transactions.} 

\item $P_j$ also extracts the transaction fees $v^{f}_i$ paid in each transaction $Tx_i$ and creates the following sum:
\begin{center}
$x_f = \sum_{i=1}^{m_{n-1}} v^{f}_i$
\end{center}

\item $P_j$ computes the local ledger state update as the transaction entry list $L^f_E$ concatenated with the hash tree of the transactions signature $d_n$: 
\begin{center}
$\Delta L_{n,j} = L^f_E~||~d_n $ %+ x_f
\end{center}

The producer then computes a second quantity that represents its individual contribution:
\begin{center}
\fbox{$h_j = h_{\Delta j}~||~Id_j$}
\end{center}
with $h_{\Delta j}$ referred as the producer \textit{local hash}:  
\begin{center}
$h_{\Delta j} = \mathcal{H}(\Delta L_{n,j})$ 
\end{center}
$h_j$ includes the producer unique identifier $Id_j$ (described in \ref{Sec:PIP}), used to verify that $P_j$ is a producer node selected for the ledger cycle and later evaluate the quality of work performed by $P_j$. 

\begin{figure}[H]
\label{fig:LLSU}
\center{\includegraphics[width=12cm]{Figures/Local_Ledger_Computation}}
\caption{\label{fig:LLSU} Flowchart illustrated the steps followed by a producer $P_j$ node during a period of time $\Delta t_{c}$ leading to the broadcast of a local hash $h_j$.}
\end{figure}
\item At $t \leq t_c + \Delta t_{c0}$, $P_j$ broadcasts $h_j$ to the other producers in the network. Figure \ref{fig:LLSU} describes the process followed by $P_j$ to produce and broadcast $h_j$.  
\end{enumerate}

\subsubsection{Local ledger state updates collection}

During the first ledger cycle phase, $P_j$ collects other $\{h_k\}_{k \in P/j}$ contributions generated by its producer peers $\{P_k\}_{k \in P/j}$ in its mempool. \\

At the end of the computation phase ($t = t_c + \Delta t_{c}$), $K_j$ local hashes are stored in $P_j$'s mempool (including the local hash producer by $P_j$). Given the set of $P$ producers selected for the ledger cycle $C_n$, the producer $P_j$ collects at most $P - 1$ contributions (\textit{e.g} $K_j = P$) with each contribution made of a local hash and a unique identifier. In an ideal world, two producers $P_j$ and $P_k$ would use the same set of transactions and as a result compute the same quantity ledger state update, leading to $\Delta L_{n,j} = \Delta L_{n,k}$. In practise, a producer may not collect exactly $P$ local hashes during $\Delta t_{c}$  (\textit{e.g} $K_j \leq P$) and may not process the exact same set of transactions as its peers. The following steps describe how each producer can verify that a ledger state update has been generated by a majority of producers and generate the reward allocated to the producers. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Voting Phase}

During the second phase (\textit{a.k.a} voting phase) of a ledger cycle, a producer $P_j$ votes on the correct ledger state update. At the end of the process, producers forward their proposed ledger state update to their peers. \\

The second phase starts at $t = t_v$ where $t_v = t_c + \Delta t_{c}$ and lasts for a period of time $\Delta t_{v}$, therefore ending at $t_v+\Delta t_{v}$.

\subsubsection{Local vote}
\label{subs:lv}
Using the $K_j$ contributions stored in its mempool, $P_j$ follows a series of steps during a period of time $\Delta t_{v0}$ ($\Delta t_{v0} < \Delta t_{v}$):
\begin{enumerate}
\item $P_j$ verifies that the same local hash $h^{maj}_{\Delta j}$ is embedded in a majority $K^{maj}$ of contributions, where $h^{maj}_{\Delta j}= max[unique(h_{\Delta k})~\forall~k\in\{K_j\}]$ and $K^{maj} = count[(h_{\Delta k} = h^{maj}_{\Delta j})~\forall~k\in\{K_j\}]$. The threshold, $K_{threshold}$, to decide if a majority of producers agrees on the same ledger state update, should be strictly greater than 50\%, due to statistical consideration. The relevant variables for a producer to decide if the same ledger state update is found by a majority of producers are $K_{min}$ and $K^{maj}$. Threshold considerations are discussed in detail in chapter~\ref{Cha:Sec}. 

If $K_j > K_{min}$ and  $K^{maj}  > K_{threshold}$ :

\begin{itemize}
\item $P_j$ creates a list $\mathcal{L}_j(prod)$ and appends to said list the identifiers of any producer $P_k$ who forwarded a contribution $h_k$ satisfying $h_{\Delta k} = h^{maj}_{\Delta j}$.\\
If $h_{\Delta j}= h^{maj}_{\Delta j}$, $P_j$ also appends its identifier to the list $\mathcal{L}_j(prod)$.
\item The producer $P_j$ then computes the following quantity: 

\begin{center}
\fbox{$v_j = h^{maj}_{\Delta j}~||~\#(L_j(prod))~||~Id_j$}
\end{center}

Where \# represents a hash tree or some other compressed data structure of the list $L_j(prod)$. $v_j$ corresponds to $P_j$'s vote on the most popular ledger state update. A hash tree of a list is useful to quickly verify that an object (an identifier) is included in the list. $\#(\mathcal{L}_j(prod))$ is a witness of the list of producers who correctly generated the most popular ledger state update according to $P_j$. 
\item At $t \leq t_v+\Delta t_{v0}$, $P_j$ broadcasts its vote $v_j$ to the other producers in the network. Figure \ref{fig:computation} displays a flowchart describing the steps followed by $P_j$ to create and broadcast $v_j$.  
\end{itemize}

\begin{figure}[H]
\label{fig:computation}
\center{\includegraphics[width=12cm]{Figures/Local_Vote_Broadcast}}
\caption{\label{fig:computation} Flowchart illustrating the series of steps followed by a producer $P_j$ to issue a local vote $v_j$.}
\end{figure}
\end{enumerate}

\subsubsection{Production reward allocation}

Shortly after the second phase starts ($t \approx t_v$), $P_j$ starts collecting votes $v_{k}$ generated by other producers $\{P_k\}_{k \in P/j}$ in its mempool. The collection lasts for a period of time $\Delta t_{v1}$ ($\Delta t_{v0} < \Delta t_{v1}< \Delta t_{v}$) after which the producer holds $V_j$ votes in its mempool ($V_{min} \leq V_j \leq P$). At this point:

\begin{enumerate}
\item $P_j$ verifies that the same local hash $h^{maj}$ is embedded in a majority of votes. With $h^{maj} = max[unique(h^{maj}_{\Delta k})~\forall~k\in\{V_j\}]$ and $V^{maj} = count[(h^{maj}_{\Delta k} = h^{maj})~\forall~k\in\{V_j\}]$, this condition is met if $V^{maj}  > V_{threshold}$ (See chapter~\ref{Cha:Sec} for more explanations). 
\item The producer $P_j$ can only participate in the next phase if the local hash computed during the computation phase, $h_{\Delta j}$, is equal to $h^{maj}$. Indeed, $P_j$ needs to have knowledge of the ledger state update of which the hash was used to vote in order to proceed. 
\end{enumerate}
 
If each producer collects the local hash generated by every producers, any two producers $P_j$ and $P_k$ would built the same list of identifiers $\mathcal{L}_j(prod) = \mathcal{L}_k(prod)$. In practise, a producer may not have collected all local hashes and as a result have an incomplete list of identifiers, yet have collected enough data to be able to issue a correct vote. We mentioned how the identifier of a producer can be appended to a local hash to verify that $P_j$ is a producer node selected for the ledger cycle and evaluate the quality of work performed by $P_j$. Indeed, $Id_j$ can be used to create and add a special transaction entry to the ledger state update, called coinbase entry, that effectively rewards the producer for its work performed during the ledger cycle. The correct (complete) list of producers who successfully built the correct (dominant) ledger state update for that cycle, $\mathcal{L}_n(prod)$,  is used to create these new transaction entries and append these to the final ledger state update generated for that cycle. It is therefore crucial that a majority of producers succeed in generating that list in order to generate the same final ledger state update. \\ 


This  second part of the voting process thus consists in creating the final list of identifiers involved in the production of the ledger state update. As explained below the final list $\mathcal{L}_n(prod)$ is obtained by merging the partial lists included in the producers' vote.
A producer $P_j$ could have produced a hash $h_{\Delta j}$ different than $h^{maj}_{\Delta j}$ yet added his identifier to $\mathcal{L}_j(prod)$ in the attempt to get some token reward allocated to producers who correctly produced the next ledger state update. In such scenario $Id_j$ would be an element of the list included in $v_j$ (or any other producer node controlled by $P_j$), but it wouldn't be included in any other list $\{\mathcal{L}_k(prod)\} \forall~k \in P/j\}$. To prevent such malicious behaviour, a rule imposes that $P_j$ only append to the final list $\mathcal{L}_n(prod)$ the identifier of a producer included in the list $\mathcal{L}_k(prod)$ of a vote $v_k$ satisfying $h^{maj}_{\Delta k} = h^{maj}$ if and only if that identifier is included in at least $P/2$ lists $\{\mathcal{L}_{k}(prod)\}_{k=1,..,V_j}$ associated to a vote $v_{k}$ satisfying $h^{maj}_{\Delta k} = h^{maj}$. Although this eliminates the risk of unethical behaviour from the producer, this also means that there would be little incentive for a producer to broadcast its vote if its identifier was not included in $\mathcal{L}_n(prod)$. However, the probability that a producer compiles the correct final list $\mathcal{L}_n(prod)$ strongly depends on the amount of votes collected. The more votes collected by a producer, the greater the probability that said producer will compile the complete final list. Although a producer may not have produced the correct local ledger state update, participating in the voting process is therefore an important contribution to the overall consensus protocol and should entitle the producer to some reward. To that end a producer $P_j$ can use the identifier of other producers included in their vote and create a second list $\mathcal{L}_j(vote)$ to account for their participation in the voting process. \\
 
At $t = t_v +  \Delta t_{v1}$,  $P_j$ follows a series of step for a period of time $\Delta t_{v2}$ ($\Delta t_{v1} + \Delta t_{v2} < \Delta t_{v}$):

\begin{enumerate}
\item $P_j$ creates a new list $\mathcal{L}_j(vote)$ and appends to said list the identifier of any producer $P_k$ who forwarded a vote $v_k$ satisfying $h^{maj}_{\Delta k} = h^{maj}$.
\item $P_j$ creates the final list $\mathcal{L}_n(prod)$ and appends to said list  the identifier of a producer included in the list $\mathcal{L}_k(prod)$ of a vote $v_k$ satisfying $h^{maj}_{\Delta k} = h^{maj}$ if and only if that identifier is included in at least $P/2$ lists $\{\mathcal{L}_{k}(prod)\}_{k=1,..,V_j}$ associated to a vote $v_{k}$ satisfying $h^{maj}_{\Delta k} = h^{maj}$. 
\item $P_j$ then creates a list $L_{CE}$ of coinbase entries for each producer whose identifier is included in $\mathcal{L}_n(prod)$. Each producer receives $x_h$ tokens. Assume that $Y_h \leq P$ identifiers are included in $\mathcal{L}_n(prod)$ and $X$ is the total number of tokens injected per cycle for the pool of $P$ producers, the quantity $x_h$ is defined such that $Y_hx_h = f_{prod}X + x_f$ where $x_f$ represents the total number of fees collected from the $m_{n-1}$ transactions and $f_{prod}$ represents the fraction of new tokens injected per cycle and distributed to the producers who built the correct ledger state update. The remaining $(1-f_{prod})X$ tokens are distributed to other contributing nodes in the network. A part of it goes to the producers who voted correctly on the previous ledger cycle update. Let $\mathcal{L}_{n-1}(vote)$ be the list of identifier of the producers who voted correctly on the previous ledger cycle update $C_{n-1}$. We demonstrate later how such list is derived during a ledger cycle. For now let's assume that $L_{CE}$ includes coinbase entries for producers involved the production of the ledger state update for this ledger cycle $C_n$ and the producers involved in the voting process of the precedent cycle $C_{n-1}$. 
\item $P_j$ then creates the final ledger state update for $C_n$  including the reward allocated to the producers for their contribution:
\begin{center}
$\mathbf{LSU_j = L^f_E~||~d_n~||L_{CE}}$
\end{center}
$P_j$ then computes its final vote:
\begin{center}
\fbox{$w_j = \mathcal{H}(LSU_j)~||~\#(\mathcal{L}_j(vote))~||~Id_j$}
\end{center}

which includes a partial list of identifiers of producers who voted for the correct ledger state update $h^{maj}$. 

\item $P_j$ then forwards $w_j$  to the other producers and collect the final votes issued by its peers. Figure \ref{fig:Vot} illustrates the different steps followed by $P_j$ during the voting phase.
\begin{figure}[H]
\label{fig:Vot}
\center{\includegraphics[width=11cm]{Figures/Global_Vote_Broadcast}}
\caption{\label{fig:Vot}Flowchart illustrating the series of steps followed by a producer $P_j$ during the voting phase of the ledger cycle.}
\end{figure}
\end{enumerate}

At the end of the voting phase ($t = t_v+\Delta t_{v}$), the producer $P_j$ holds $W_j$ final votes in its mempool with $W_j \leq K_n$ where $K_n \leq P$ is the actual total number of producers who correctly computed $h^{maj}$.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Synchronisation Phase}


The third and final phase (\textit{a.k.a} synchronisation phase) of a ledger cycle starts at $t = t_s$, with $t_s = t_{n,0} + \Delta t_{c} + \Delta t_{v}$, and lasts for a period of time $\Delta t_{s}$, therefore ending at $t_s+\Delta t_s = t_{n,0}  + \Delta t_{cycle}$.

During a period of time $\Delta t_{s0} < \Delta t_{s}$, $P_j$ executes the following steps:

\begin{enumerate}
\item $P_j$ defines the ledger state update $\Delta L_n$ for the cycle $C_n$ as:\\
 $\mathcal{H}(\Delta L_n)  = max[unique(\mathcal{H}(LSU_k))~\forall~k\in\{W_j\}]$ and the associated number of final votes collected: $P_n = count[(\mathcal{H}(LSU_k) = \mathcal{H}(\Delta L_n))~\forall~k\in\{W_j\}]$ and verifies that $P_n > P_{threshold}$.
\item $P_j$ creates a new list $\mathcal{L}_{n}(vote)$ and appends to $\mathcal{L}_{n}(vote)$ the identifier of a producer included in the list $\mathcal{L}_{k}(vote)$ of a vote $w_k$ satisfying $\mathcal{H}(LSU_k) = \mathcal{H}(\Delta L_n)$ if and only if the identifier is included in at least $K_n/2$ lists $\{\mathcal{L}_{k}(vote)\}$ associated to a vote $w_{k}$ satisfying $\mathcal{H}(LSU_k) = \mathcal{H}(\Delta L_n)$. Note that $K_n$ can be easily computed as it corresponds to the number of identifier of producers who correctly computed the ledger state update and are therefore included in $\mathcal{L}_{n}(prod)$.
\item $P_j$ then creates the following quantities:
\begin{center}
$\mathbf{H_j = \mathcal{H}(\Delta L_n)~||~Id_j}$\\
$\mathbf{H_{j'} = \mathcal{H}(\Delta L_n)~||~\#(\mathcal{L}_{n}(vote))~||~Id_j}$
\end{center}
\item The producer then broadcasts $H_j$ and  $H_{j'}$  to the entire network. $H_j$ is destined to the user nodes while  $H_{j'}$ is sent to the workers who store $\#(\mathcal{L}_{n}(vote))$ in their mempool. 
\end{enumerate}

During the time period [$t_{s}, t_s + \Delta t_{cycle}$], user nodes in the network collect $H_k~\forall k \in P$ quantities from producers. Extracting the identifier $Id_k$ in $H_k$ a user node can easily compile a list of identical $\mathcal{H}(\Delta L_n)$ hash values. Once a user node has collected more than $P/2$ identical hash values, they can send a request to producers to receive $\Delta L_n$ and verifies the validity if it against any $H_k$ quantity previously stored. When valid, the user can safely synchronise their local copy to the ledger. The balance of accounts stored on the ledger are updated and the producers effectively collect their rewards. \\

Worker nodes also store the lists $\mathcal{L}_{n}(vote)$ embedded in each $H_k$ quantity. If selected to be a producer for the next cycle $C_{n+1}$, the worker can use these to generate the reward allocated to the producers who correctly voted for the ledger state update during $C_{n+1}$.\\

Figure~\ref{fig:cycle} summarises the different phases of the ledger cycle.

\begin{figure}[H]
\center{\includegraphics[width=14cm]{Figures/Catalyst_Cycle}}
\caption{Illustration of the different phases of a ledger cycle}
\label{fig:cycle}
\end{figure}

The various parameters and thresholds mentioned in this chapter and their impact on the network security are discussed in Chapter~\ref{Cha:Sec}.
